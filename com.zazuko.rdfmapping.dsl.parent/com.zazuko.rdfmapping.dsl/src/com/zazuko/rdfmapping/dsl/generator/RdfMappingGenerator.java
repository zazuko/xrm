/*
 * generated by Xtext 2.25.0
 */
package com.zazuko.rdfmapping.dsl.generator;

import java.util.ArrayList;
import java.util.List;

import javax.inject.Inject;
import javax.inject.Named;

import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;

import com.zazuko.rdfmapping.dsl.generator.common.GeneratorConstants;
import com.zazuko.rdfmapping.dsl.generator.common.ModelAccess;
import com.zazuko.rdfmapping.dsl.generator.csvw.CsvwDialectContext;
import com.zazuko.rdfmapping.dsl.generator.csvw.CsvwDialectGenerator;
import com.zazuko.rdfmapping.dsl.generator.rml.RmlDialectGenerator;
import com.zazuko.rdfmapping.dsl.generator.shacl.ShaclGenerator;
import com.zazuko.rdfmapping.dsl.rdfMapping.Domainmodel;
import com.zazuko.rdfmapping.dsl.rdfMapping.Mapping;
import com.zazuko.rdfmapping.dsl.rdfMapping.OutputType;
import com.zazuko.rdfmapping.dsl.rdfMapping.Shape;

/**
 * Generates code from your model files on save.
 * 
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
public class RdfMappingGenerator extends AbstractGenerator {

	@Inject
	private ModelAccess modelAccess;

	@Inject
	@Named(GeneratorConstants.DIALECT_RML)
	private RmlDialectGenerator rmlGenerator;

	@Inject
	@Named(GeneratorConstants.DIALECT_R2RML)
	private RmlDialectGenerator r2rmlGenerator;

	@Inject
	@Named(GeneratorConstants.DIALECT_CARML)
	private RmlDialectGenerator carmlGenerator;

	@Inject
	private CsvwDialectGenerator csvwGenerator;

	@Inject
	private ShaclGenerator shaclGenerator;

	@Override
	public void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		Domainmodel model = resource.getContents().stream().filter(current -> current instanceof Domainmodel)
				.map(current -> (Domainmodel) current).findFirst().get();

		if (model == null) {
			return;
		}

		// TODO: this needs cleanup later on -- ATM if their is a 'base' declared, we
		// only look for shapes, ignore mappings and generate SHACL
		if (model.getBase() != null) {
			String base = model.getBase();

			List<Shape> shapes = all(resource, Shape.class);

			String dslFileName = resource.getURI().lastSegment().toString();
			String outFileBase = dslFileName.substring(0, dslFileName.lastIndexOf("."));

			fsa.generateFile(outFileBase + ".shacl.ttl", shaclGenerator.generateTurtle(shapes, base));

			return;
		}

		if (model.getOutputType() == null) {
			return;
		}
		if (model.getOutputType().getType() == null) {
			return;
		}

		OutputType outputType = model.getOutputType().getType();

		List<Mapping> mappings = all(resource, Mapping.class);

		String dslFileName = resource.getURI().lastSegment().toString();
		String outFileBase = dslFileName.substring(0, dslFileName.lastIndexOf("."));

		switch (outputType) {
		case RML:
			fsa.generateFile(outFileBase + ".rml.ttl", rmlGenerator.generateTurtle(mappings));
			break;
		case R2RML:
			fsa.generateFile(outFileBase + ".r2rml.ttl", r2rmlGenerator.generateTurtle(mappings));
			break;
		case CARML:
			fsa.generateFile(outFileBase + ".carml.ttl", carmlGenerator.generateTurtle(mappings));
			break;
		case CSVW:
			CsvwDialectContext ctx = new CsvwDialectContext(modelAccess, mappings);
			fsa.generateFile(outFileBase + ".csv.meta.json", csvwGenerator.generateJson(mappings, ctx));
			break;
		}
	}

	@SuppressWarnings("unchecked")
	private <X> List<X> all(Resource resource, Class<X> clazz) {
		List<X> result = new ArrayList<>();
		TreeIterator<EObject> it = resource.getAllContents();
		while (it.hasNext()) {
			EObject candidate = it.next();
			if (clazz.isInstance(candidate)) {
				result.add((X) candidate);
			}
		}

		return result;
	}
}
