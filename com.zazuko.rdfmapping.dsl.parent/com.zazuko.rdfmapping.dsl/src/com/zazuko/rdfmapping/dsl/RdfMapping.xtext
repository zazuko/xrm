grammar com.zazuko.rdfmapping.dsl.RdfMapping with org.eclipse.xtext.common.Terminals

generate rdfMapping "http://www.zazuko.com/rdfmapping/dsl/RdfMapping"

Domainmodel :
    (elements+=Element)*;
  
Element:
    SourceGroup | LogicalSource | PrefixHolder | Mapping |
    LanguageTagDefinition | DialectGroup;

DatatypesDefinition: 
	'datatypes' name=ID BLOCK_BEGIN
		prefix=Prefix
		(types+=Datatype)*
	BLOCK_END;

Datatype:
	name=ID (value=STRING)?;
	
LanguageTagDefinition: {LanguageTagDefinition}
	'language-tags' BLOCK_BEGIN
		(languageTags+=LanguageTag)*
	BLOCK_END;
	
LanguageTag:
	name=ID;
  
SourceGroup:
    'source-group' name=ID BLOCK_BEGIN
    	('type' typeRef=SourceTypeRef)?
    	('source' (sourceIsQuery ?= 'query')? source=STRING)?
    	('dialect' dialect=[DialectGroup])?
    	(logicalSources+=LogicalSource)*
    BLOCK_END;
    
LogicalSource:
	'logical-source' name=ID BLOCK_BEGIN
		('type' typeRef=SourceTypeRef)?
		('source' (sourceIsQuery ?= 'query')? source=STRING)?
		('dialect' dialect=[DialectGroup])?
		('iterator' iterator=STRING)?
		'referenceables'
			(referenceables+=Referenceable)*
	BLOCK_END;
	
enum SourceType:
	XML='xml' 
	| RDB = 'rdb'
	| CSV = 'csv'
	;

// do not reference an enum directly - if no value is declared, EMF will initialize the 
// reference with the first entry of the enum instead of null.
SourceTypeRef:
	type=SourceType
;

Referenceable:	
    name=ID (value=STRING)? (nullValueMarker=NullValueDeclaration)?;
    
NullValueDeclaration:
	'null' nullValue=STRING;
    
DialectGroup:
	'dialect' name=ID BLOCK_BEGIN
		'delimiter' delimiter=STRING &
		('commentPrefix' commentPrefix=STRING)? &
		('doubleQuote' doubleQuote=BooleanLiteral)? &
		('encoding' encoding=STRING)? &
		('header' header=BooleanLiteral)? &
		('headerRowCount' headerRowCount=INT)? & 
		('lineTerminators' lineTerminators=STRING)? &
		('quoteChar' quoteChar=STRING)? & 
		('skipBlankRows' skipBlankRows=BooleanLiteral)? &
		('skipColumns' skipColumns=INT)? &
		('skipInitialSpace' skipInitialSpace=BooleanLiteral)? &
		('skipRows' skipRows=INT)? &
		('trim' trim=BooleanLiteral)? &
	BLOCK_END;

BooleanLiteral:
    value?='true' | {BooleanLiteral} 'false';
    
Vocabulary:	
	'vocabulary' name=ID BLOCK_BEGIN
    	prefix=Prefix
		('classes' (classes+=RdfClass)* )?
	    ('properties' (properties+=RdfProperty)*)?	
    BLOCK_END;
   
PrefixHolder:
    DatatypesDefinition | Vocabulary;   
    
Prefix:
	'prefix' label=STRING iri=STRING;
    
RdfProperty:
	name=ID (value=STRING)?;
	
RdfClass:
	name=ID (value=STRING)?;	
    
Mapping:
	'map' name=ID 'from' source=[LogicalSource|QualifiedName] BLOCK_BEGIN
		'subject' subjectIriMapping=TemplateValuedTerm
		 ('types' (subjectTypeMappings+=SubjectTypeMapping)+ LINE_END?)?
		 ('properties' (poMappings+=PredicateObjectMapping)+)?
	BLOCK_END;
	
SubjectTypeMapping:	
	type=[RdfClass|RdfPrefixedName];

PredicateObjectMapping:	
	property=[RdfProperty|RdfPrefixedName] 
	term=ValuedTerm;
	
ValuedTerm:
	ReferenceValuedTerm | TemplateValuedTerm | LinkedResourceTerm | ConstantValuedTerm | ParentTriplesMapTerm;
	
ReferenceValuedTerm:
	'from' reference=[Referenceable]
	('with' 'datatype' datatype=[Datatype|RdfPrefixedName] | 'with' 'language-tag' languageTag=[LanguageTag])?
	('as' termTypeRef=TermTypeRef)?
	LINE_END?;

ConstantValuedTerm:
	'constant' constant=STRING
	LINE_END?;

TemplateValuedTerm:
	'template' template=STRING 'with' (references+=[Referenceable])+
	('as' termTypeRef=TermTypeRef)?
	LINE_END?;
	
LinkedResourceTerm:
	'link' mapping=[Mapping] 'with' (references+=[Referenceable])+
	 LINE_END?;
	 
ParentTriplesMapTerm:
	'parent-map' mapping=[Mapping]
	LINE_END?;

QualifiedName:
    ID ('.' ID)*;
    
// on EObjects to be addressed with RdfPrefixedName, don't forget to change 
/// com.zazuko.rdfmapping.dsl.ui.contentassist.RealRdfMappingProposalProvider.getStyledDisplayString(IEObjectDescription)
/// com.zazuko.rdfmapping.dsl.services.RdfDslConverters.RdfPrefixedName()
RdfPrefixedName:
    ID ':' ID;
    
terminal BLOCK_BEGIN: '{';
terminal BLOCK_END: '}';
terminal LINE_END: ';';

enum TermType:
 Literal='Literal'
 | IRI='IRI'
 | BlankNode='BlankNode'
 ;
 
// do not reference an enum directly - if no value is declared, EMF will initialize the 
// reference with the first entry of the enum instead of null.
TermTypeRef:
	type=TermType
;
