/*
 * generated by Xtext 2.25.0
 */
package com.zazuko.rdfmapping.dsl.ui.contentassist;

import java.util.Collections;
import java.util.Set;
import java.util.function.Predicate;

import javax.inject.Inject;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.jface.text.contentassist.ICompletionProposal;
import org.eclipse.jface.viewers.StyledString;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.naming.IQualifiedNameConverter;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;

import com.zazuko.rdfmapping.dsl.common.RdfMappingConstants;
import com.zazuko.rdfmapping.dsl.generator.common.ModelAccess;
import com.zazuko.rdfmapping.dsl.rdfMapping.LogicalSource;
import com.zazuko.rdfmapping.dsl.rdfMapping.Mapping;
import com.zazuko.rdfmapping.dsl.rdfMapping.OmniMap;
import com.zazuko.rdfmapping.dsl.rdfMapping.OutputType;
import com.zazuko.rdfmapping.dsl.rdfMapping.PredicateObjectMapping;
import com.zazuko.rdfmapping.dsl.rdfMapping.RdfClass;
import com.zazuko.rdfmapping.dsl.rdfMapping.RdfProperty;
import com.zazuko.rdfmapping.dsl.rdfMapping.ReferenceValuedTerm;
import com.zazuko.rdfmapping.dsl.rdfMapping.SourceGroup;
import com.zazuko.rdfmapping.dsl.rdfMapping.SourceType;
import com.zazuko.rdfmapping.dsl.rdfMapping.TemplateValuedTerm;
import com.zazuko.rdfmapping.dsl.services.RdfPrefixedNameConverter;

/**
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#content-assist
 * on how to customize the content assistant.
 */
public class RdfMappingProposalProvider extends AbstractRdfMappingProposalProvider {
	@Inject
	private IQualifiedNameConverter qualifiedNameConverter;

	@Inject
	private RdfPrefixedNameConverter rdfDslConverter;

	@Inject
	private ModelAccess modelAccess;

	@Inject
	private OmniMapKeyProposalGenerator omniMapKeyProposalGenerator;

	protected StyledString getStyledDisplayString(IEObjectDescription description) {
		EObject eo = description.getEObjectOrProxy();
		if (eo instanceof RdfProperty //
				|| eo instanceof RdfClass //
		) {
			String origQualifiedNameString = this.qualifiedNameConverter.toString(description.getQualifiedName());
			String qualifiedNameString = this.rdfDslConverter.toString(origQualifiedNameString);
			return getStyledDisplayString(eo, qualifiedNameString,
					qualifiedNameConverter.toString(description.getName()));
		}
		return super.getStyledDisplayString(description);
	}

	@Override
	public void completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext,
			ICompletionProposalAcceptor acceptor) {
		if (contentAssistContext.getCurrentModel() instanceof PredicateObjectMapping) {
			OutputType type = modelAccess.outputType(contentAssistContext.getCurrentModel());
			Predicate<ICompletionProposal> filter = new RmlishOutputTypeCompletionProposalPredicate("parent-map",
					keyword, type)//
							.and(new WhitelistedEnumTypeCompletionProposalPredicate<OutputType>("multi-reference",
									keyword, Collections.singleton(OutputType.CARML), type));
			super.completeKeyword(keyword, contentAssistContext,
					new FilteringCompletionProposalAcceptor(acceptor, filter));

		} else if (contentAssistContext.getCurrentModel() instanceof ReferenceValuedTerm
				|| contentAssistContext.getCurrentModel() instanceof TemplateValuedTerm) {
			OutputType type = modelAccess.outputType(contentAssistContext.getCurrentModel());
			Predicate<ICompletionProposal> filter = new RmlishOutputTypeCompletionProposalPredicate("as", keyword, type);
			
			// #30 for a subjectIriMapping, don't offer 'Literal'
			if (contentAssistContext.getCurrentModel() instanceof TemplateValuedTerm) {
				EObject container = contentAssistContext.getCurrentModel().eContainer();
				if (container instanceof Mapping) {
					Mapping mapping = (Mapping) container;
					// make sure we really have subjetIriMapping in our hands
					if (mapping.getSubjectIriMapping() == contentAssistContext.getCurrentModel()) {
						filter = filter.and(new BlacklistedCompletionProposalPredicate("Literal", keyword));
					}
				}
			}
			
			super.completeKeyword(keyword, contentAssistContext, new FilteringCompletionProposalAcceptor(acceptor,
					filter));

		} else if (contentAssistContext.getCurrentModel() instanceof SourceGroup) {
			SourceGroup cast = (SourceGroup) contentAssistContext.getCurrentModel();
			this.completeKeywordForSourceDefinition(keyword, contentAssistContext, acceptor,
					cast.getTypeRef() != null ? cast.getTypeRef().getType() : null);

		} else if (contentAssistContext.getCurrentModel() instanceof LogicalSource) {
			LogicalSource cast = (LogicalSource) contentAssistContext.getCurrentModel();
			this.completeKeywordForSourceDefinition(keyword, contentAssistContext, acceptor,
					cast.getTypeRef() != null ? cast.getTypeRef().getType() : null);

		} else {
			super.completeKeyword(keyword, contentAssistContext, acceptor);
		}
	}

	private void completeKeywordForSourceDefinition(Keyword keyword, ContentAssistContext contentAssistContext,
			ICompletionProposalAcceptor acceptor, SourceType type) {

		Predicate<ICompletionProposal> filter = //
				new WhitelistedEnumTypeCompletionProposalPredicate<SourceType>("xml-namespace-extension", keyword, //
						Collections.singleton(SourceType.XML), //
						type) //
								.and( //
										new WhitelistedEnumTypeCompletionProposalPredicate<SourceType>("dialect",
												keyword, //
												Collections.singleton(SourceType.CSV), //
												type)//
								);

		super.completeKeyword(keyword, contentAssistContext, new FilteringCompletionProposalAcceptor(acceptor, filter));

	}

	@Override
	public void complete_BLOCK_BEGIN(EObject model, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		acceptor.accept(this.createCompletionProposal(RdfMappingConstants.TOKEN_BLOCK_BEGIN,
				RdfMappingConstants.TOKEN_BLOCK_BEGIN, null, context));
	}

	@Override
	public void complete_BLOCK_END(EObject model, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		acceptor.accept(this.createCompletionProposal(RdfMappingConstants.TOKEN_BLOCK_END,
				RdfMappingConstants.TOKEN_BLOCK_END, null, context));
	}
	
	@Override
	public void complete_LINE_END(EObject model, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		if (model instanceof PredicateObjectMapping) {
			PredicateObjectMapping pom = (PredicateObjectMapping)model;
			if (pom.getTerm() == null || pom.isLineEnd()) {
				return; // do not offer ';' if there is no valuedTerm or there is already a ';'
			}
		}
		acceptor.accept(this.createCompletionProposal(RdfMappingConstants.TOKEN_LINE_END,
				RdfMappingConstants.TOKEN_LINE_END, null, context));
	}

	@Override
	public void completeOmniMapEntry_Key(EObject model, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		Set<String> proposals = this.omniMapKeyProposalGenerator.createKeyProposals((OmniMap)model);
		for (String proposal: proposals) {
			if (!acceptor.canAcceptMoreProposals()) {
				return;
			}
			acceptor.accept(this.createCompletionProposal(proposal, proposal, null, context));
		}
	}

}
